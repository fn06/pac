module Ast = Ast
module Parser = Parser
module Lexer = Lexer

(* module Core = struct *)
(*   type 'a set = 'a list *)
(*   type version = Ast.version *)
(*   type name = Ast.name *)
(*   type package = Ast.package *)
(*   type dependency = package * (name * version set) *)
(*   type dependencies = dependency set *)
(*   type query = package set *)
(*   type resolver_resolution = dependencies -> query -> package set *)
(**)
(*   let check_query_present ~(query : query) ~(resolution : package set) = *)
(*     List.for_all (fun q -> List.mem q resolution) query *)
(**)
(*   let check_dependency_closure (dependencies : dependencies) (resolution : package set) = *)
(*     List.for_all (fun (p, (m, vs)) -> *)
(*       match List.mem p resolution with *)
(*       | false -> true *)
(*       | true -> (match List.find_opt (fun (o, v) -> *)
(*                       String.equal o m && List.mem v vs) resolution with *)
(*                 | Some _ -> true *)
(*                 | None -> false) *)
(*     ) dependencies *)
(**)
(*   let check_version_uniqueness (resolution : package set) = *)
(*     let module NameSet = Set.Make(String) in *)
(*     let names = List.fold_left (fun set (n, _) -> NameSet.add n set) NameSet.empty resolution *)
(*     in NameSet.cardinal names = List.length resolution *)
(**)
(*   let check_resolution (dependencies : dependencies) ~(query : query) ~(resolution : package set) = *)
(*     check_query_present ~query ~resolution && *)
(*     check_dependency_closure dependencies resolution && *)
(*     check_version_uniqueness resolution *)
(* end *)
(**)
(* let a1 = "A", "1" *)
(* let b1 = "B", "1" *)
(* let c1 = "C", "1" *)
(* let d1 = "D", "1" *)
(* let d2 = "D", "2" *)
(* let d3 = "D", "3" *)
(* let dependencies = [ *)
(*     (a1, ("B", [ "1" ])); *)
(*     (a1, ("C", [ "1" ])); *)
(*     (b1, ("D", [ "1"; "2" ])); *)
(*     (c1, ("D", [ "2"; "3" ])); *)
(*   ] *)
(**)
(* let resolution = [ a1; b1; c1; d2 ] *)
(* let query = [ a1 ] *)
(**)
(* let () = *)
(*   Printf.printf "check_query_present %b\n" (Core.check_query_present ~query ~resolution ); *)
(*   Printf.printf "check_dependency_closure %b\n" (Core.check_dependency_closure dependencies resolution ); *)
(*   Printf.printf "check_version_uniqueness %b\n" (Core.check_version_uniqueness resolution ); *)
(*   Printf.printf "check_resolution %b\n" (Core.check_resolution dependencies ~query ~resolution ); *)
(**)
(* module Concurrent = struct *)
(*   open Core *)
(*   type granularity = version -> version *)
(*   type concurrent_resolution = granularity -> dependencies -> query -> package set *)
(**)
(*   let encode_name (n : name) (g : version) : name = *)
(*     n ^ "-" ^ g *)
(**)
(*   let encode_query (g : granularity) (q : query) : query = *)
(*     List.map (fun (n, v) -> (encode_name n (g v), v)) q *)
(**)
(*   let encode_dep (g : granularity) (((n, v), (m, vs)) : dependency) : dependencies = *)
(*     let module VersionSet = Set.Make(String) in *)
(*     let granular = List.fold_left (fun set v -> VersionSet.add (g v) set) VersionSet.empty vs in *)
(*     (* Direct case *) *)
(*     if VersionSet.cardinal granular <= 1 then *)
(*       let w = VersionSet.choose granular in *)
(*       [ (encode_name n (g v), v), (encode_name m w, vs) ] *)
(*    (* Split case *) *)
(*     else *)
(*       let intermediate = Printf.sprintf "i-%s-%s-%s" n v m in *)
(*       let gvs = VersionSet.to_list granular in *)
(*       let dependant = *)
(*         [ ((encode_name n (g v), v), (intermediate, gvs)) ] *)
(*       in *)
(*       let intermediates = *)
(*         List.concat_map (fun w -> *)
(*           let vs_w = List.filter (fun v -> (g v) = w) vs in *)
(*           [ ((intermediate, w), (encode_name m w, vs_w)) ] *)
(*         ) gvs *)
(*       in *)
(*       dependant @ intermediates *)
(**)
(*   let encode_dependencies (g : granularity) (dependencies : dependencies) : dependencies = *)
(*     dependencies |> List.concat_map (encode_dep g) *)
(* end *)
(**)
(**)
(* let a100 = "A", "1.0.0" *)
(* let b100 = "B", "1.0.0" *)
(* let c100 = "C", "1.0.0" *)
(* let d100 = "D", "1.0.0" *)
(* let d200 = "D", "2.0.0" *)
(* let d201 = "D", "2.0.1" *)
(* let d300 = "D", "3.0.0" *)
(* let dependencies = [ *)
(*     (a1, ("B", [ "1.0.0" ])); *)
(*     (a1, ("C", [ "1.0.0" ])); *)
(*     (b1, ("D", [ "1.0.0"; "2.0.0"; "2.0.1" ])); *)
(*     (c1, ("D", [ "2.0.0"; "2.0.1"; "3.0.0" ])); *)
(*   ] *)
(**)
(* let reduced = Concurrent.encode_dependencies *)
(*            (fun v -> List.hd (String.split_on_char '.' v)) *)
(*            dependencies *)
(**)
(* let print_dependencies (dependencies : Core.dependencies) = *)
(*   List.iter (fun ((n, v), (m, vs)) -> *)
(*     Printf.printf "%s %s -> %s %s\n" n v m (String.concat " " vs) *)
(*   ) dependencies *)
(**)
(* let () = print_dependencies reduced *)
